#!/usr/bin/env bash 
#
# Desc

## Globals
BOLD=$(tput bold)
NORMAL=$(tput sgr0)


## Display functions
err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
}

step() {
  local title="$1"
  printf '\n%s%s%s\n' "===> " "$title" "..."
}


## Packages
ask_action () {
  local prompt="$1"
  local allowed="$2"

  local response
  read -p "$prompt"$'\n' response

  local code="$(echo ${response:0:1} | tr '[:upper:]' '[:lower:]')"

  if [[ "$code" =~ $allowed ]]; then
    echo $code
  fi
}

print_set () {
  local dir="$1"
  local pkg_file="$2"
  local pkg_set="$(basename $pkg_file)"

  # Print header for the package set
  echo
  echo "--- Set: ${dir}/${BOLD}${pkg_set}${NORMAL}"

  # Print contents of set, with two space indent
  cat $pkg_file | column -x -c 40 | sed 's/^/  /'
  echo
}

edit_set () {
  local pkg_file="$1"
  local -n set_pkgs="$2"

  # Read lines from pkg file on unit 3
  while read -r -u 3 line; do
    printf '\n%s\n' $line
    local action=$(ask_action 'y/n?' '[yn]')
    
    if [[ "$action" == "y" ]]; then
      set_pkgs+=$line
      printf 'Adding %s to list\n' $line
    fi

  done 3< $pkg_file
}


# Construct package list
build_list () {
  local -n all_items="$1"
  local dir="$2"

  step "Collecting $dir"

  for item_file in ${dir}/*; do
  
    print_set "$dir" "$item_file"
  
    action=$(ask_action '(I)nstall, (S)kip, or (E)dit?' '[ies]')
  
    case "$action" in 
      i)
        mapfile -t -O "${#all_items[@]}" all_items < "$item_file"
        ;;
      e)
        edit_set "$item_file" all_items
        ;;
      *)
        continue
        ;;
    esac
  done
}

install_packages () {
  local -n install_pkgs="$1"

  step "Installing packages"
  for pkg in "${install_pkgs[@]}"; do
    sudo apt install -y "$pkg"
  done
}


## Snaps
install_snaps () {
  local -n install_snaps="$1"

  step "Installing snaps"
  for snap in "${install_snaps[@]}"; do
    sudo snap install "$snap"
  done
}


## Repos
build_repos () {
  local -n build_repos="$1"
  local dir="$2"

  step "Installing repos"

  for repo_file in "${dir}/*"; do
    echo "repo_file: $repo_file"
  done

}

## Option parsing
PARAMS=""
DRY_RUN=false
DO_PACKAGES=false
DO_SNAPS=false
DO_REPOS=false

while (( "$#" )); do
  case "$1" in
    -d|--dry-run)
    	DRY_RUN=true
      shift 1
      ;;
    -s|--steps)
      steps="$(echo "$2" | tr '[:upper:]' '[:lower:]')"

      for step in ${steps//,/ }; do
        case "$step" in
          packages)
            DO_PACKAGES=true
            echo "Adding to pipeline: package install"
            ;;
          snaps)
            DO_SNAPS=true
            echo "Adding to pipeline: snap install"
            ;;
          repos)
            DO_REPOS=true
            echo "Adding to pipeline: repo install"
            ;;
        esac
      done
      shift 2
      ;;
    --) # end argument parsing
      shift
      break
      ;;
    -*|--*=) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
      PARAMS="$PARAMS $1"
      shift
      ;;
  esac
done
# set positional arguments in their proper place
eval set -- "$PARAMS"



## Main
if $DO_PACKAGES; then
  pkgs=()
  build_list pkgs "packages"
  install_packages pkgs
fi

if $DO_SNAPS; then
  snaps=()
  build_list snaps "snaps"
  install_snaps snaps
fi

if $DO_REPOS; then
  declare -A repos
  build_repos repos "repos"
fi

printf '\n%s\n' "Setup complete!"
